---
title: "updateメソッドの使い道 〜AsyncNotifierで事前条件を検証する〜"
emoji: "⌛"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["flutter", "dart", "riverpod"]
published: false
---

契約プログラミングをご存知でしょうか？簡単に言うと契約プログラミングとは、メソッドの事前条件と事後条件を明示的に記述することで、メソッドの正しさを保証するプログラミング手法です。

例えば、サインイン処理を実行する前に未認証状態であることを確認する処理を書き、サインイン処理が成功した後に認証状態であることを確認する処理を書くことで、サインイン処理の正しさを保証することができます。

この記事ではRiverpodのAsyncNotifierに上記の検証を実装した際に私が遭遇した問題とその解決策を紹介します。

## 認証状態を管理するAsyncNotifier

まずは認証状態を管理するAsyncNotifierを実装します。

```dart
@riverpod
class Authenticator extends _$Authenticator {
  Future<SignInStatus> build() async {
    // CognitoやFirebaseなどの認証パッケージを使って認証状態を取得するイメージ
    final authDriver = await ref.watch(authDriverProvider.future);
    return await authDriver.fetchSignInStatus();
  }

  Future<void> signIn() async {
    // サインイン処理
  }
}
```

## 事前条件を検証する

```dart
Future<void> signIn() async {
  assert(state == SignInStatus.signedOut); // 事前条件を検証する
  // サインイン処理
  state = AsyncValue.loading();
  state = AsyncValue.guard(() async {
    final result = await authDriver.signIn();
    return switch (result) {
      SignInResult.success: AsyncValue.data(SignInStatus.signedIn);
      _ => AsyncValue.data(SignInStatus.signedOut);
    }
  });
}
```

## 発生する問題

上記のように事前条件の検証は成功するときと失敗する時があります。何が原因なのでしょうか？

失敗する場合は、`state`が`AsyncValue.loading()`の状態で`assert`が実行されるためです。
では、なぜ`state`が`AsyncValue.loading()`の状態なのでしょうか？

それは非同期であるbuildメソッドが完了していないまま、signInメソッドが実行されてしまうためです。
大抵のケースではbuildメソッドはすぐに完了するため、この問題は発生しません。

しかし、buildメソッドが完了するまでに時間がかかる場合や逆にすぐさまsignInメソッドを実行しようとするとこの問題が発生します。
私はこの問題に遭遇したのは unit test を書いていたときでした。unit test では瞬間的にsignInメソッドを実行するため、この問題が発生しました。
（実機で動作を確認している際には発生しなかったので、最初は原因がわかりませんでした。）

## 解決策

問題を解決するには、buildメソッドが完了するまでsignInメソッドを実行できないようにする必要があります。
言い換えれば、signInメソッド内でbuildメソッドが完了するまで待機する必要があります。

これを実現するために`update`メソッドを使いましょう。

updateメソッドでは引数に渡した処理（クロージャ）をbuildメソッドが完了した後に実行してくれます。
そのため、signInの処理をupdateメソッドに渡す形に変更しましょう。

```dart
// 問題がある変更の仕方
Future<void> signIn({
  required String email,
  required String password,
}) async {
  await update((state) async {
    assert(state == SignInStatus.signedOut); // 事前条件を検証する
    // サインイン処理
    final authDriver = await ref.watch(authDriverProvider.future);
    final signInResult = await authDriver.signIn(email, password);
    state = switch (signInResult) {
      SignInResult.success: AsyncValue.data(SignInStatus.signedIn);
      _ => AsyncValue.data(SignInStatus.signedOut);
    };
  });
}
```

updateメソッドを使用した形に変更しました。しかし、このままでは動作しません。
なぜならば、updateメソッドは与えられたクロージャの中で`state`を変更するのではなく、返された値でstateを書き換えるためです。

そのため、正しくは以下のような形に変更する必要があります。

```dart
// 正しい変更の仕方
Future<void> signIn({
  required String email,
  required String password,
}) async {
  await update((state) async {
    assert(state == SignInStatus.signedOut); // 事前条件を検証する
    // サインイン処理
    final authDriver = await ref.watch(authDriverProvider.future);
    final signInResult = await authDriver.signIn(email, password);
    return switch (signInResult) {
      SignInResult.success: AsyncValue.data(SignInStatus.signedIn);
      _ => AsyncValue.data(SignInStatus.signedOut);
    };
  });
}
```

これで正しく動作するようになりましたが、signInが失敗して例外が発生した場合はどうなるでしょうか？
これまでは AsyncValue.guard が例外をキャッチしてくれていましたが、updateメソッドでは例外をキャッチしてくれません。
同じように例外をキャッチしてstateを書き換えるにはupdateメソッドの実行をtry-catchもしくはAsyncValue.guardで囲む必要があります。

```dart
Future<void> signIn({
  required String email,
  required String password,
}) async {
  try {
    await update((state) async {
      // 処理
    });
  } catch (e) {
    state = AsyncValue.error(e);
  }
}

// または
Future<void> signIn({
  required String email,
  required String password,
}) async {
  state = AsyncValue.guard(() async {
    await update((state) async {
      // 処理
    });
  });
}
```

## なぜupdateメソッドを使うと問題が解決するのか？

updateメソッドはbuildメソッドが完了するまで処理を待機するため、buildメソッドが完了する前にsignInメソッドが実行されることはありません。
なぜそう言い切れるのでしょうか？それはupdateメソッドの実装を少しだけ覗いてみるとわかります。

```dart
then
```

thenが使用されています。thenはFutureの処理が完了した後に実行される処理を登録するメソッドです。
このことから、updateメソッドはbuildメソッドが完了するまで処理を待機することがわかります。

## まとめ

今回はAsyncNotifierのupdateメソッドを使って事前条件を検証する方法を紹介しました。
updateメソッドの存在自体知らなかったという方も多いのではないでしょうか？あるいは、updateメソッドの存在は知っていたけど使い方がわからなかったという方もいるかもしれません。

AsyncNotifierでbuildメソッドが完了するまで処理を待機する方法は他にもあると思いますが、updateメソッドを使う方法は良い選択肢の1つになるのではないでしょうか？
