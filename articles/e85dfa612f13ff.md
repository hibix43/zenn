---
title: "[Flutter] Providerで取得したListItemの状態を“しばらく”だけ保持するテクニック"
emoji: "⏱️"
type: "tech"
topics: ["flutter", "dart", "riverpod", "performance"]
published: false
---

## はじめに

ListViewのListItemには複数のデータのうち、一部のデータを渡して表示することが多いと思います。しかし、ひとつずつデータを渡すよりも、ListItem側でProviderを(できればselectorを使って)取得して表示したいこともあると思います。IDだけ渡して、ListItem側でProviderからデータを取得するイメージですね。

ただ、ListViewのListItemは見えなくなると破棄されてしまうので、スクロールを頻繁に行うと、ListItemが破棄されて再度表示されるたびにProviderからデータを取得し直すことになります。Providerからのデータ取得が重い場合、パフォーマンスに影響が出る可能性があります。

ListItemが見えなくなっても状態を一時的に維持できれば、Providerからのデータ取得を減らすことができ、パフォーマンスの向上が期待できます。

この記事では、`AutomaticKeepAliveClientMixin` を応用して **「一時的に状態を保持する」** 方法を紹介します。

## 基本：AutomaticKeepAliveClientMixin とは

`AutomaticKeepAliveClientMixin` を使うと、Widget がリスト外にスクロールしても破棄されず、状態を保持できます。

```dart
import 'dart:async';

class MyListItem extends StatefulWidget {
  const MyListItem({super.key});

  @override
  State<MyListItem> createState() => _MyListItemState();
}

class _MyListItemState extends State<MyListItem> with AutomaticKeepAliveClientMixin {
  var _counter = 0;

  // 状態を維持するかどうかを返す
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    // super.build を呼び出す必要がある。忘れずに
    super.build(context);

    return ListTile(
      title: Text('Counter: $_counter'),
      onTap: () {
        setState(() {
          _counter++;
        });
      },
    );
  }
}
```

これで必ずListItemが見えなくなっても状態を維持します。ただ、こうした使い方をすることはないと思います（ずっと状態を維持することになってしまうので）。

ということで具体的にありそうなケースを考えてみます。

## 応用：Providerのデータを一定時間だけ保持する

以下の例では、`userProvider` からユーザー情報を取得し、
データが読み込まれたあと **10秒間だけ状態を保持する** ようにしています。

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 仮のUserモデル
class User {
  final String id;
  final String name;
  final String email;
  User(this.id, this.name, this.email);
}

// 仮のProvider（APIなどから取得する想定）
final userProvider = FutureProvider.family<User, String>((ref, userId) async {
  await Future.delayed(const Duration(milliseconds: 500)); // ダミーの遅延
  return User(userId, 'User $userId', 'user$userId@example.com');
});

class TimedKeepAliveUserItem extends ConsumerStatefulWidget {
  const TimedKeepAliveUserItem({super.key, required this.userId});

  final String userId;

  @override
  ConsumerState<TimedKeepAliveUserItem> createState() => _TimedKeepAliveUserItemState();
}

class _TimedKeepAliveUserItemState extends ConsumerState<TimedKeepAliveUserItem>
    with AutomaticKeepAliveClientMixin {
  bool _shouldKeepAlive = false;
  Timer? _keepAliveTimer;

  @override
  bool get wantKeepAlive => _shouldKeepAlive;

  void _startKeepAlive() {
    setState(() {
      _shouldKeepAlive = true;
    });

    // 既存タイマーをキャンセル
    _keepAliveTimer?.cancel();

    // 10秒後に状態維持を解除
    _keepAliveTimer = Timer(const Duration(seconds: 10), () {
      setState(() {
        _shouldKeepAlive = false;
      });
      updateKeepAlive();
    });

    updateKeepAlive();
  }

  @override
  void dispose() {
    _keepAliveTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);

    final userAsync = ref.watch(userProvider(widget.userId));

    return userAsync.when(
      data: (user) {
        if (!_shouldKeepAlive) {
          // データが読み込まれたタイミングで状態保持を開始
          WidgetsBinding.instance.addPostFrameCallback((_) => _startKeepAlive());
        }
        return ListTile(
          title: Text(user.name),
          subtitle: Text(user.email),
          trailing: const Text("(保持中)"),
        );
      },
      loading: () => const ListTile(title: Text('読み込み中...')),
      error: (e, _) => ListTile(title: Text('エラー: $e')),
    );
  }
}
```

この実装により、次のような動作になります：

- 初回表示時に `userProvider` からデータを取得
- データがロードされた時点で `_startKeepAlive()` を呼び出し
- ListItem が非表示になっても 10 秒間は破棄されずに状態を保持
- 10 秒経過後、自動で破棄対象に戻る

## 注意点

- `AutomaticKeepAliveClientMixin` は Widget の破棄を防ぐだけで、永続キャッシュではありません
- 保持時間を長くしすぎるとメモリを圧迫します。特に画像を表示するケースでは気をつけないといとも簡単にアプリがクラッシュします
- `updateKeepAlive()` を呼び忘れると状態が反映されないため注意が必要です

## まとめ

`AutomaticKeepAliveClientMixin` は、単なる「状態を保持する」だけでなく、
**「いつまで保持するか」も制御できる** のが強みです。

今回紹介したように：

- ✅ Provider のデータがロードされたタイミングで保持を開始
- ✅ 一定時間後に自動解除
- ✅ パフォーマンスとメモリのバランスを両立

といった運用設計を取り入れることで、
Flutter アプリのリスト描画をより効率的にチューニングできます。

頻繁にスクロールされるリストや、重いデータ取得が絡む UI で特に効果を発揮しますので、ぜひ試してみてください。
