---
title: "ofメソッドの挙動の仕組み〜InheritedWidgetはどのように動いているか〜"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["flutter", "inheritedwidget"]
published: false
---

`Theme.of(context)` や `MediaQuery.of(context)` といったコードをよく見かけると思います。

これらはInheritedWidgetを利用しています。InheritedWidgetは、子孫に対して、データを提供するためのウィジェットです。

このようなコードを見かけたときに、どのように動いているかを知っていますか？

この記事では、InheritedWidgetの仕組みを理解し、その動作を確認します。

## InheritedWidgetとは

InheritedWidgetは、子孫に対して、データを提供するためのウィジェットです。

単にデータを提供するのであれば、引数でデータを渡すことで、子孫にデータを提供することができます。

しかし、このやり方では、データを提供するために、毎回引数を渡す必要があります。
これは、あるウィジェットから子ウィジェットにデータを渡す場合は問題ありませんが、
その子ウィジェットからさらに子ウィジェットにデータを渡す場合といった具合に渡す先との距離が遠くなるにつれて、
データを渡すために必要なコードが増えていきます。

これを解消するために、InheritedWidgetを利用します。

InheritedWidget (を継承したウィジェット) は、子孫に共有したいデータを保持します。
そのデータを利用したい子孫ウィジェットは、InheritedWidget（を継承したウィジェット）を参照します。
こうすることで、データを渡すために必要なコードが減り、コードの重複を減らすことができます。

また、InheritedWidgetは、データの変更を検知して、必要に応じて子孫に変更を通知することができます。
InheritedWidgetでは、データの変更があったときに、その変更を通知するかどうかを制御することができます。
この制御は引数で渡すやり方ではできません。引数による共有では、データの変更があった場合、必ず子孫に通知されてしまいます。
この点で、InheritedWidgetは柔軟なデータの共有ができます。

## どのように動いているか

こちらはInheritedWidgetのコードです。

なお、本記事では assertion やコメントを省略しています。

```dart
abstract class InheritedWidget extends ProxyWidget {
   const InheritedWidget({ super.key, required super.child });

  @override
  InheritedElement createElement() => InheritedElement(this);

  @protected
  bool updateShouldNotify(covariant InheritedWidget oldWidget);
}
```

ものすごくシンプルですよね。

この `updateShouldNotify` が、データの変更を通知するかどうかを制御します。
`covariant` は指定した引数の型が、継承した型と一致することを保証します。
通常の型の指定では、型が一致しない場合にエラーが発生します。
number 型で宣言されている引数を持つメソッドを override するとき int 型でもエラーが発生します。
このとき `covariant` を指定すると、number 型で宣言されている引数を持つメソッドを override するとき int 型でもエラーが発生しません。
つまり、サブクラスでもスーパークラスのメソッドを override できるようになります。

`updateShouldNotify` は我々、アプリ開発者が override します。
そのため `covariant` を指定して、 InheritedWidget を継承した独自のウィジェットを渡すことができるようになっているのです。

余談
`updateShouldNotify` は、データの変更を通知するかどうかを制御しますが、私は `updateShouldNotify` という名前に違和感がありました。
bool を返すのであれば `updateShouldNotify` ではなく `shouldNotify` という名前のほうが良いのでは？と疑問に感じていました。
ただ、一緒にお仕事しているある方から `updateShouldNotify` は getter ではなく、引数を受け取るメソッドであるが故に `update` を動詞として含んでいるのではないか、という意見を頂き、それ以来 `updateShouldNotify` という名前に違和感を感じなくなりました。

## `updateShouldNotify` はどのように動いているか

`updateShouldNotify` は、データの変更を通知するかどうかを制御すると書きました。
では、この `updateShouldNotify` はどのように動いているのでしょうか？

まず `updateShouldNotify` の呼び出し元を見てみます。
検索してみると `InheritedElement#update` のみ呼び出していることがわかります。

```dart
@override
void updated(InheritedWidget oldWidget) {
  if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) {
    super.updated(oldWidget);
  }
}
```

`updateShouldNotify` は、引数で渡された `oldWidget` と 自身の `widget` を比較して、
`updateShouldNotify` が `true` を返す場合は、`super.updated(oldWidget)` を呼び出します。
逆に言えば `updateShouldNotify` が `false` を返す場合は、`super.updated(oldWidget)` を呼び出さないため、
子孫にデータの変更を通知しないことになります。

このようにして、`updateShouldNotify` は、データの変更を通知するかどうかを制御しています。

では `super.updated(oldWidget)` は何をしているのでしょうか？

これは、`InheritedElement` が継承している `ProxyElement` の `updated` メソッドを呼び出しています。

```dart
@protected
void updated(covariant ProxyWidget oldWidget) {
  notifyClients(oldWidget);
}
```

`ProxyElement` の `notifyClients` は抽象メソッドです。そのため `ProxyElement` には `notifyClients` の実装がありません。

```dart
@protected
void notifyClients(covariant ProxyWidget oldWidget);
```

`InheritedElement` 側に `notifyClients` の実装があります。

```dart
@override
void notifyClients(InheritedWidget oldWidget) {
  for (final Element dependent in _dependents.keys) {
    notifyDependent(oldWidget, dependent);
  }
}
```