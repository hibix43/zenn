---
title: "setState()に非同期処理を渡してはいけない理由"
emoji: "🙅‍♂️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["flutter"]
published: false
---

Flutterの状態管理には様々な方法がありますが、その中でも一番簡単なのが`setState()`ですよね。しかし、`setState`で非同期処理を行うことはできず、`assert`のエラーが発生します。

なぜ、`assert`を使用して非同期処理を行うことを禁止しているのでしょうか？
今回は無理やり非同期処理を行うとどうなるのかを確認してみます。

## 環境

- Flutter 3.7.12
- Dart 2.19.6

## setState()のソースコードをのぞいてみる

`setState()`のソースコードを見てみると`assert`で非同期処理を行うことを禁止していることがわかります。`_element!.markNeedsBuild()`は状態が変化したことを伝え、画面を更新するように設定する処理です。

```dart
@protected
void setState(VoidCallback fn) {
  // 非同期処理とは関係ない assert は省略
  final Object? result = fn() as dynamic;
  assert(() {
    if (result is Future) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('setState() callback argument returned a Future.'),
        ErrorDescription(
          'The setState() method on $this was called with a closure or method that '
          'returned a Future. Maybe it is marked as "async".',
        ),
        ErrorHint(
          'Instead of performing asynchronous work inside a call to setState(), first '
          'execute the work (without updating the widget state), and then synchronously '
          'update the state inside a call to setState().',
        ),
      ]);
    }
    return true;
  }());
  _element!.markNeedsBuild(); // 画面を更新するように設定する
}
```

## エラーを発生させてみる

`setState()`のコールバックに非同期処理を渡すとエラーは以下のように表示されます。
（`_MyHomePageState#ae179`は`setState()`を呼び出した`State`のインスタンス）

:::message
登場するコードはFlutterの公式サンプルであるカウンターアプリを改変したものです。
:::

```dart
void _incrementCounter() {
  setState(() async {
    await Future.delayed(Duration(seconds: 1));
    _counter++;
  });
}
```

>setState() callback argument returned a Future.
>
>The setState() method on _MyHomePageState#ae179 was called with a closure or method that returned a Future. Maybe it is marked as "async”.
>
>Instead of performing asynchronous work inside a call to setState(), first execute the work (without updating the widget state), and then synchronously update the state inside a call to setState()

ざっくりとした訳すと「`setState()`のコールバックが`Future`を返しています。非同期処理を行う場合は、`setState()`のコールバック内では非同期処理を行わず、非同期処理を行った後に`setState()`を呼び出してください」といった感じでしょうか。

実際、`setState()`の前に非同期処理を行い、その後に`setState()`を呼び出すとエラーは発生しません。

```dart
void _incrementCounter() async {
  await Future.delayed(Duration(seconds: 1));
  setState(() {
    _counter++;
  });
}
```

## 無理やり非同期の処理を行えるようにする

`setState()`のコールバックに非同期の処理を行うことを禁止していることがわかったので、無理やり非同期処理を行えるようにしてみます。

```dart
@protected
void setState(VoidCallback fn) {
  final Object? result = fn() as dynamic;
  // assert を削除
  _element!.markNeedsBuild();
}
```

`assert`を削除すると、`setState()`のコールバックとして非同期処理を渡してもエラーは発生しません。

```dart
void _incrementCounter() {
  setState(() async {
    await Future.delayed(Duration(seconds: 1));
    _counter++;
  });
}
```

しかし、画面が更新されずに`_counter`の値が更新されていることがわかります。
これが`setState()`のコールバックに非同期処理を渡すことを禁止している理由です。

```dart
void _incrementCounter() {
  setState(() async {
    await Future.delayed(Duration(seconds: 1));
    _counter++;
  });
  print(_counter); // 1
}
```

なぜ画面が更新されないのでしょうか。`async/await`を使用しているのだから、非同期処理が終わるまで待ってくれるはずですよね。
`async/await`を使用しているのに非同期処理が終わるまで待ってくれないのは、`setState()`では`async/await`を使用していない（`then`も）からです。

では、なぜ`async/await`を使用していないのでしょうか。
`async/await`を使用すると、setState()は非同期関数になってしまい、`setState()`の呼び出し元で`await`を使用する必要が出てきます。となると、あらゆるところで`await`を使用する必要が出てきてしまいます。（awaitを使用しないとなると、結局、状態と画面に不整合が生じることになります。）

```dart
final Object? result = fn() as dynamic; // 非同期処理を同期的に実行するようなコードにはなっていない
_element!.markNeedsBuild(); // fn()の実行が終わる前に呼び出されてしまう
```

そのため、`_markNeedsBuild()`がコールバックの処理が終わる前に呼び出されてしまい、画面が更新されないのです。

## async/awaitを使わずに非同期処理を実行してみる

```dart
void _incrementCounter() {
  setState(() {
    Future.delayed(Duration(seconds: 1)).then((_) {
      _counter++;
    });
    // 以下のように書いても同じ
    // Future.delayed(Duration(seconds: 1));
    // _counter++;
  });
}
```

これでも同様に画面が更新されずに`_counter`の値が更新されていることがわかります。
なぜでしょうか。もうお分かりですよね。上と同じく、`_markNeedsBuild()`がコールバックの処理が終わる前に呼び出されてしまうからです。

## まとめ

`setState()`のコールバックに非同期処理を渡すことを禁止している理由は、`setState()`では`async/await`を使用していないからです。そのため、`_markNeedsBuild()`がコールバックの処理が終わる前に呼び出されてしまい、画面が更新されないのです。
画面と状態が同期していない状態になってしまうので、`setState()`のコールバックに非同期処理を渡すことは禁止されているのです。
